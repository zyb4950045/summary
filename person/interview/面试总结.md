##面试总结
####JAVA基础
	1. JAVA中的几种基本数据类型是什么,各自占用多少字节.
		八种基本数据类型,int(4),short(2),byte(1),long(8),float(4),double(8),char(2),boolean(1)
	2. String类能被继承吗,为什么.
		String是一个被final修饰的类,不能被继承
	3. String,Stringbuffer,StringBuilder的区别.
		String是Java中基础且重要的类,并且String也是Immutable类的典型实现,被声明为final class,除了hash这个属性其它属性都声明为final,因为它的不可变性,所以例如拼接字符串时候会产生很多无用的中间对象,如果频繁的进行这样的操作对性能有所影响.
		StringBuffer就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类,提供append和add方法,可以将字符串添加到已有序列的末尾或指定位置,它的本质是一个线程安全的可修改的字符序列,把所有修改数据的方法都加上了synchronized.但是保证了线程安全是需要性能的代价的.在很多情况下我们的字符串拼接操作不需要线程安全,这时候StringBuilder登场了,StringBuilder是JDK1. 5发布的,它和StringBuffer本质上没什么区别,就是去掉了保证线程安全的那部分,减少了开销.
		StringBuffer 和 StringBuilder 二者都继承了 AbstractStringBuilder ,底层都是利用可修改的char数组(JDK 9 以后是 byte数组).
	4. ArrayList和LinkedList有什么区别.
		ArrayList底层是数组实现,具有数组的特性,增删慢,查询快
		LinkedList底层是采用链表来实现,增删快,查询慢
	5. 讲讲类的实例化顺序,比如父类静态数据,构造函数,字段,子类静态数据,构造函数,字段,当new的时候,他们的执行顺序.
		类的实例化顺序：先静态再父子
		父类静态数据->子类静态数据->父类字段->子类字段->父类构造函数->子类构造函数
	6. 用过哪些Map类,都有什么区别,HashMap是线程安全的吗,并发下使用的Map是什么,他们内部原理分别是什么,比如存储方式,hashcode,扩容,默认容量等.
		最常用的Map实现类有:HashMap,ConcurrentHashMap（jdk1. 8）,LinkedHashMap,TreeMap,Hashtable；
		其中最频繁的是HashMap和ConcurrentHashMap,他们的主要区别是HashMap是非线程安全的.ConcurrentHashMap是线程安全的.
		并发下可以使用ConcurrentHashMap和Hashtable,他们的主要区别是：
		(1). ConcurrentHashMap的hash计算公式：(key. hascode()^ (key. hascode()>>> 16)) & 0x7FFFFFFF
			Hashtable的hash计算公式：key. hascode()& 0x7FFFFFFF
		(2). HashTable存储方式都是链表+数组,数组里面放的是当前hash的第一个数据,链表里面放的是hash冲突的数据
			ConcurrentHashMap是数组+链表+红黑树
		(3). 默认容量都是16,负载因子是0. 75.就是当hashmap填充了75%的busket是就会扩容,最小的可能性是（16*0. 75）,一般为原内存的2倍
		(4). 线程安全的保证：Hashtable是在每个操作方法上面加了synchronized来达到线程安全,ConcurrentHashMap线程是使用CAS(compore and swap)来保证线程安全的
	7. JAVA8的ConcurrentHashMap为什么放弃了分段锁,有什么问题吗,如果你来设计,你如何设计.
		jdk8 放弃了分段锁而是用了Node锁,减低锁的粒度,提高性能,并使用CAS操作来确保Node的一些操作的原子性,取代了锁.
		但是ConcurrentHashMap的一些操作使用了synchronized锁,而不是ReentrantLock,虽然说jdk8的synchronized的性能进行了优化,但是我觉得还是使用ReentrantLock锁能更多的提高性能
	8. 有没有有顺序的Map实现类,如果有,他们是怎么保证有序的.
		顺序的 Map 实现类:LinkedHashMap,TreeMap
		LinkedHashMap 是基于元素进入集合的顺序或者被访问的先后顺序排序,TreeMap 则是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定).
	9. 抽象类和接口的区别,类可以继承多个类么,接口可以继承多个接口么,类可以实现多个接口么.
		抽象类有构造方法,接口没有；抽象类中可以有方法的实现,类只能单继承,接口可以继承多个接口,类可以实现多个接口
	10. 继承和聚合的区别在哪.
		继承指的是一个类继承另外的一个类的功能,并可以增加它自己的新功能的能力,继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识.
		聚合体现的是整体与部分,拥有的关系,此时整体与部分之间是可分离的,他们可以具有各自的生命周期；比如计算机与CPU,公司与员工的关系等；
	11. IO模型有哪些,讲讲你理解的nio ,他和bio,aio的区别是啥,谈谈reactor模型.
		BIO：同步阻塞式IO,服务器实现模式为一个连接一个线程,即客户端有连接请求时服务器端就需要启动一个线程进行处理,如果这个连接不做任何事情会造成不必要的线程开销,当然可以通过线程池机制改善.
		NIO：同步非阻塞式IO,服务器实现模式为一个请求一个线程,即客户端发送的连接请求都会注册到多路复用器上,多路复用器轮询到连接有I/O请求时才启动一个线程进行处理.
		reactor模型：反应器模式（事件驱动模式）：当一个主体发生改变时,所有的属体都得到通知,类似于观察者模式.
	12. 反射的原理,反射创建类实例的三种方式是什么.
		反射的原理：如果知道一个类的名称/或者它的一个实例对象, 就能把这个类的所有方法和变量的信息(方法名,变量名,方法,修饰符,类型,方法参数等等所有信息)找出来.
		反射创建类实例的三种方式：
		1. Class.forName("com.A");
		2. new A().getClass();
		3. A.class;
	13. 反射中Class.forName和ClassLoader区别 .
		class.forName()除了将类的.class文件加载到jvm中之外,还会对类进行解释,执行类中的static块.
		classLoader只干一件事情,就是将.class文件加载到jvm中,不会执行static中的内容,只有在newInstance才会去执行static块.
	14. 描述动态代理的几种实现方式,分别说出相应的优缺点.
		动态代理有两种实现方式,分别是：jdk动态代理和cglib动态代理
		jdk动态代理的前提是目标类必须实现一个接口,代理对象跟目标类实现一个接口,从而避过虚拟机的校验.
		cglib动态代理是继承并重写目标类,所以目标类和方法不能被声明成final.
	15. 动态代理与cglib实现的区别.
		动态代理有两种实现方式,分别是：jdk动态代理和cglib动态代理
		jdk动态代理的前提是目标类必须实现一个接口,代理对象跟目标类实现一个接口,从而避过虚拟机的校验.
		cglib动态代理是继承并重写目标类,所以目标类和方法不能被声明成final.
	16. 为什么CGlib方式可以对接口实现代理.
		cglib动态代理是继承并重写目标类,所以目标类和方法不能被声明成final.而接口是可以被继承的.
	17. final的用途.
		1). final修饰的对象不能被修改；
		2). final修饰的类不能被继承；
		3). final修饰的方法不能被重写；
	18. 写出三种单例模式实现 .
		懒汉式（先定义,用的时候再创建）,饿汉式（定义并创建好,用的时候直接拿）,饱汉式（静态内部类）
	19. 如何在父类中为子类自动完成所有的hashcode和equals实现?这么做有何优劣.
		父类的equals不一定满足子类的equals需求.比如所有的对象都继承Object,默认使用的是Object的equals方法,在比较两个对象的时候,是看他们是否指向同一个地址.
		但是我们的需求是对象的某个属性相同,就相等了,而默认的equals方法满足不了当前的需求,所以我们要重写equals方法.
		如果重写了equals 方法就必须重写hashcode方法,否则就会降低map等集合的索引速度.
	20. 请结合OO设计理念,谈谈访问修饰符public,private,protected,default在应用设计中的作用.
		public 所有的地方都能访问
		protected 外部包不能访问
		default  子类和外部包不能访问
		private 只能在类内部访问
	21. 深拷贝和浅拷贝区别.
		浅拷贝只拷贝指针,深拷贝就是拷贝他的值,重新生成的对象.
	22. 数组和链表数据结构描述,各自的时间复杂度.
		数组是将元素在内存中连续存放,由于每个元素占用内存相同,可以通过下标迅速访问数组中任何元素.
		链表恰好相反,链表中的元素在内存中不是顺序存储的,而是通过存在元素中的指针联系到一起.
		访问数组中第 n 个数据的时间花费是 O(1) 但是要在数组中查找一个指定的数据则是 O(N) .当向数组中插入或者删除数据的时候,最好的情况是在数组的末尾进行操作,时间复杂度是 O(1) ,但是最坏情况是插入或者删除第一个数据,时间复杂度是 O(N) .在数组的任意位置插入或者删除数据的时候,后面的数据全部需要移动,移动的数据还是和数据个数有关所以总体的时间复杂度仍然是 O(N) . 
		在链表中查找第 n 个数据以及查找指定的数据的时间复杂度是 O(N) ,但是插入和删除数据的时间复杂度是 O(1)
	23. error和exception的区别,CheckedException,RuntimeException的区别.
		Error（错误）表示系统级的错误和程序不必处理的异常,是java运行环境中的内部错误或者硬件问题.比如：内存资源不足等.对于这种错误,程序基本无能为力,除了退出运行外别无选择,它是由Java虚拟机抛出的.
		Exception（违例）表示需要捕捉或者需要程序进行处理的异常,它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题,是程序必须处理的.
		Exception又分为运行时异常,受检查异常.
		RuntimeException(运行时异常),表示无法让程序恢复的异常,导致的原因通常是因为执行了错误的操作,建议终止程序,因此,编译器不检查这些异常.
		CheckedException(受检查异常),是表示程序可以处理的异常,也即表示程序可以修复（由程序自己接受异常并且做出处理）, 所以称之为受检查异常.
	24. 请列出5个运行时异常.
		NullPointerException
		IndexOutOfBoundsException
		ClassCastException
		ArrayStoreException
		BufferOverflowException
	25. 在自己的代码中,如果创建一个java.lang.String类,这个类是否可以被类加载器加载?为什么.
		不可以,双亲委派模式会保证父类加载器先加载类,就是BootStrap（启动类）加载器加载jdk里面的java.lang.String类,而自定义的java.lang.String类永远不会被加载到
	26. 说一说你对java.lang.Object对象中hashCode和equals方法的理解.在什么场景下需要重新实现这两个方法.
		父类的equals不一定满足子类的equals需求.比如所有的对象都继承Object,默认使用的是Object的equals方法,在比较两个对象的时候,是看他们是否指向同一个地址.
		但是我们的需求是对象的某个属性相同,就相等了,而默认的equals方法满足不了当前的需求,所以我们要重写equals方法.
		如果重写了equals 方法就必须重写hashcode方法,否则就会降低map等集合的索引速度.
	27. 在jdk1.5中,引入了泛型,泛型的存在是用来解决什么问题.
		泛型的好处是在编译的时候检查类型安全,并且所有的强制转换都是自动和隐式的,提高代码的重用率.
	28. 这样的a.hashcode()有什么用,与a.equals(b)有什么关系.
		hashCode()方法是相应对象整型的 hash值.它常用于基于hash的集合类,如Hashtable,HashMap,LinkedHashMap等等.它与 equals() 方法关系特别紧密.根据 Java 规范,两个使用 equal() 方法来判断相等的对象,必须具有相同的 hash code.
	29. 有没有可能2个不相等的对象有相同的hashcode.
		有可能,最简单的方法,百分百实现的方式就是重写hascode();
	30. Java中的HashSet内部是如何工作的.
		HashSet 的内部采用 HashMap 来实现.由于 Map 需要 key 和 value,所以HashSet中所有 key 的都有一个默认 value.类似于 HashMap,HashSet 不允许重复的 key,只允许有一个null key,意思就是 HashSet 中只允许存储一个 null 对象.
	31. 什么是序列化,怎么序列化,为什么序列化,反序列化会遇到什么问题,如何解决.
		序列化：把对象转换为字节序列的过程称为对象的序列化.
		反序列化：把字节序列恢复为对象的过程称为对象的反序列化.
		详细：https://blog. csdn. net/riemann_/article/details/87835260
	32. java8的新特性.
		https://blog. csdn. net/yitian_66/article/details/81010434
####JVM知识

	1. 什么情况下会发生栈内存溢出.
		https://blog.csdn.net/qq_31615049/article/details/82980799
	2. JVM的内存结构,Eden和Survivor比例.
		Java堆（Heap）
			对于大多数应用来说,Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.
			Java堆是垃圾收集器管理的主要区域,因此很多时候也被称做“GC堆”.如果从内存回收的角度看,由于现在收集器基本都是采用的分代收集算法,所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间,From Survivor空间,To Survivor空间等.
			根据Java虚拟机规范的规定,Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可,就像我们的磁盘空间一样.在实现时,既可以实现成固定大小的,也可以是可扩展的,不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）.
			如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常.
		方法区（Method Area）
			方法区（Method Area）与Java堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-Heap（非堆）,目的应该是与Java堆区分开来.
			对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说,很多人愿意把方法区称为“永久代”（Permanent Generation）,本质上两者并不等价,仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区,或者说使用永久代来实现方法区而已.
			Java虚拟机规范对这个区域的限制非常宽松,除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾收集.相对而言,垃圾收集行为在这个区域是比较少出现的,但并非数据进入了方法区就如永久代的名字一样“永久”存在了.这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载,一般来说这个区域的回收“成绩”比较难以令人满意,尤其是类型的卸载,条件相当苛刻,但是这部分区域的回收确实是有必要的.
			根据Java虚拟机规范的规定,当方法区无法满足内存分配需求时,将抛出OutOfMemoryError异常. 
		程序计数器（Program Counter Register）
			程序计数器（Program Counter Register）是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的行号指示器.在虚拟机的概念模型里（仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现）,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成. 
			由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令.因此,为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间的计数器互不影响,独立存储,我们称这类内存区域为“线程私有”的内存. 
				如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法,这个计数器值则为空（Undefined）.
			此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.
		JVM栈（JVM Stacks）
			与程序计数器一样,Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的,它的生命周期与线程相同.虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表,操作栈,动态链接,方法出口等信息.每一个方法被调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程. 
			局部变量表存放了编译期可知的各种基本数据类型（boolean,byte,char,short,int,float,long,double）,对象引用（reference类型,它不等同于对象本身,根据不同的虚拟机实现,它可能是一个指向对象起始地址的引用指针,也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）.
			其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot）,其余的数据类型只占用1个.局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.
			在Java虚拟机规范中,对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展,只不过Java虚拟机规范中也允许固定长度的虚拟机栈）,当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常.
		本地方法栈（Native Method Stacks）
			本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的,其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务,而本地方法栈则是为虚拟机使用到的Native方法服务.虚拟机规范中对本地方法栈中的方法使用的语言,使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它.甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一.与虚拟机栈一样,本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常.
	3. JVM内存为什么要分成新生代,老年代,持久代.新生代中为什么要分为Eden和Survivor.
	4. JVM中一次完整的GC流程是怎样的,对象如何晋升到老年代,说说你知道的几种主要的JVM参数.
	5. 你知道哪几种垃圾收集器,各自的优缺点,重点讲下cms和G1,包括原理,流程,优缺点.
	6. 垃圾回收算法的实现原理.
	7. 当出现了内存溢出,你怎么排错.
	8. JVM内存模型的相关知识了解多少,比如重排序,内存屏障,happen-before,主内存,工作内存等.
	9. 简单说说你了解的类加载器,可以打破双亲委派么,怎么打破.
	10. 讲讲JAVA的反射机制.
	11. 你们线上应用的JVM参数有哪些.
	12. g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择.
	13. 怎么打出线程栈信息.
	14请解释如下jvm参数的含义： 
		-server -Xms512m -Xmx512m -Xss1024K 
		-XX:PermSize=256m -XX:MaxPermSize=512m 
		-XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80 
		-XX:+UseCMSInitiatingOccupancyOnly.
		
		-Xms设置堆的最小空间大小.
		-Xmx设置堆的最大空间大小.
		-XX:NewSize设置新生代最小空间大小.
		-XX:MaxNewSize设置新生代最大空间大小.
		-XX:PermSize设置永久代最小空间大小.
		-XX:MaxPermSize设置永久代最大空间大小.
		-Xss设置每个线程的堆栈大小.
	
####开源框架知识

	1. 简单讲讲tomcat结构,以及其类加载器流程,线程模型等.
	2. tomcat如何调优,涉及哪些参数 .
	3. 讲讲Spring加载流程.
	4. Spring AOP的实现原理.
	5. 讲讲Spring事务的传播属性.
	6. Spring如何管理事务的.
	7. Spring怎么配置事务（具体说出一些关键的xml 元素）.
	8. 说说你对Spring的理解,非单例注入的原理?它的生命周期?循环注入的原理,aop的实现原理,说说aop中的几个术语,它们是怎么相互工作的.
	9. Springmvc中DispatcherServlet初始化过程.
	10. netty的线程模型,netty如何基于reactor模型上实现的.
	11. 为什么选择netty.
	12. 什么是TCP粘包,拆包.解决方式是什么.
	13. netty的fashwheeltimer的用法,实现原理,是否出现过调用不够准时,怎么解决.
	14. netty的心跳处理在弱网下怎么办.
	15. netty的通讯协议是什么样的.
	16. springmvc用到的注解,作用是什么,原理.
	17. springboot启动机制.
	
####操作系统

	1. Linux系统下你关注过哪些内核参数,说说你知道的.
	2. Linux下IO模型有几种,各自的含义是什么.
	select poll epoll
	3. epoll和poll有什么区别.
	4. 平时用到哪些Linux命令.
	netstat lsof查看网络
	free 查看内存
	df du 参看磁盘
	grep 查找文件内容 find查找文件
	ps查看进程
	less more cat tail查看文件
	chmod修改权限
	5. 用一行命令查看文件的最后五行.
	tail -5 file.txt
	6. 用一行命令输出正在运行的java进程.
	jps -lvm
	7. 介绍下你理解的操作系统中线程切换过程.
	8. 进程和线程的区别.
	9. top命令之后有哪些内容,有什么作用.
	查看当前cpu的负载
	10. 线上CPU爆高,请问你如何找到问题所在.
	top -pH按当前cpu负载从高到低显示
	
####多线程

	1. 多线程的几种实现方式,什么是线程安全.
	2. volatile的原理,作用,能代替锁么.
	保证可见性和有序性,不保证原子性
	3. 画一个线程的生命周期状态图.
	4. sleep和wait的区别.
	5. sleep和sleep(0)的区别.
	6. Lock与Synchronized的区别.
	7. synchronized的原理是什么,一般用在什么地方(比如加在静态方法和非静态方法的区别,
	   静态方法和非静态方法同时执行的时候会有影响吗),解释以下名词：重排序,自旋锁,偏向锁,轻量级锁,可重入锁,公平锁,非公平锁,乐观锁,悲观锁.
	8. 用过哪些原子类,他们的原理是什么.
	9. 实现一个生产者消费者模式,不用阻塞队列
	10. JUC下研究过哪些并发工具,讲讲原理.
	11. 用过线程池吗,如果用过,请说明原理,并说说newCache和newFixed有什么区别,构造函数的各个参数的含义是什么,比如coreSize,maxsize等.
	12. 线程池的关闭方式有几种,各自的区别是什么.
	13. 假如有一个第三方接口,有很多个线程去调用获取数据,现在规定每秒钟最多有10个线程同时调用它,如何做到.
	14. spring的controller是单例还是多例,怎么保证并发的安全.
	15. 用三个线程按顺序循环打印abc三个字母,比如abcabcabc.
	16. ThreadLocal用过么,用途是什么,原理是什么,用的时候要注意什么.
	ThreadLocalMap 防止内存泄漏
	17. 如果让你实现一个并发安全的链表,你会怎么做.
	18. 有哪些无锁数据结构,他们实现的原理是什么.
	19. 讲讲java同步机制的wait和notify.
	20. CAS机制是什么,如何解决ABA问题.
	21. 多线程如果线程挂住了怎么办.
	22. countdowlatch和cyclicbarrier的内部原理和用法,以及相互之间的差别(比如countdownlatch的await方法和是怎么实现的).
	23. 对AbstractQueuedSynchronizer了解多少,讲讲加锁和解锁的流程,独占锁和公平所加锁有什么不同.
	24. 使用synchronized修饰静态方法和非静态方法有什么区别.
	25. 简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处.
	26. 导致线程死锁的原因?怎么解除线程死锁.
	死锁的四个必要条件: 请求和保持,不可剥夺,互斥,循环等待
	保证加锁顺序一致避免循环等待
	27. 非常多个线程（可能是不同机器）,相互之间需要等待协调,才能完成某种工作,问怎么设计这种协调方案.
	28. 用过读写锁吗,原理是什么,一般在什么场景下用.
	读锁共享,写锁互斥.读阻塞写,写阻塞读写,读之前互相不阻塞 持有写锁的线程可以获取读锁,完成锁降级
	29. 开启多个线程,如果保证顺序执行,有哪几种实现方式,或者如何保证多个线程都执行完再拿到结果.
	30. 延迟队列的实现方式,delayQueue和时间轮算法的异同.

####TCP与HTTP

	1. http1.0, http1.1, http2.0有什么区别.
	http1.0一个请求对应一个线程
	2. TCP三次握手和四次挥手的流程,为什么断开连接要4次,如果握手只有两次,会出现什么.
	3. TIME_WAIT和CLOSE_WAIT的区别.
	4. 说说你知道的几种HTTP响应码,比如200, 302, 404.
	5. 当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候,计算机做了哪些工作步骤.
	6. TCP如何保证可靠性,说说TCP头的结构.
	7. 如何避免浏览器缓存.
	8. 如何理解HTTP协议的无状态性.
	9. 简述Http请求get和post的区别以及数据包格式.
	10. HTTP有哪些method
	11. 简述HTTP请求的报文格式.
	12. HTTP的长连接是什么意思.
	13. HTTPS的加密方式是什么,讲讲整个加密解密流程.
	14. Http和https的三次握手有什么区别.
	15. 什么是分块传送.
	16. Session和cookie的区别.
	
####架构设计与分布式

	1. 用java自己实现一个LRU.
    // 继承LinkedHashMap, 最好自己写个不用继承LinkedHashMap的方法
    public class LRUCache<K, V> extends LinkedHashMap<K, V> {
        private final int MAX_CACHE_SIZE;

        public LRUCache(int cacheSize) {
            // 使用构造方法 public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
            // initialCapacity,loadFactor都不重要
            // accessOrder要设置为true，按访问排序
            super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);
            MAX_CACHE_SIZE = cacheSize;
        }

        @Override
        protected boolean removeEldestEntry(Map.Entry eldest) {
            // 超过阈值时返回true，进行LRU淘汰
            return size() > MAX_CACHE_SIZE;
        }
    }
	2. 分布式集群下如何做到唯一序列号.
	雪花算法(snowflake)
	3. 设计一个秒杀系统,30分钟没付款就自动关闭交易.
	4. 如何使用redis和zookeeper实现分布式锁?有什么区别优缺点,会有什么问题,分别适用什么场景.（延伸：如果知道redlock,讲讲他的算法实现,争议在哪里）
	5. 如果有人恶意创建非法连接,怎么解决.
	6. 分布式事务的原理,优缺点,如何使用分布式事务,2pc 3pc 的区别,解决了哪些问题,还有哪些问题没解决,如何解决,你自己项目里涉及到分布式事务是怎么处理的.
	7. 什么是一致性hash.
	8. 什么是restful,讲讲你理解的restful.
	9. 如何设计一个良好的API.
	10. 如何设计建立和保持100w的长连接.
	11. 解释什么是MESI协议(缓存一致性).
	12. 说说你知道的几种HASH算法,简单的也可以.
	13. 什么是paxos算法, 什么是zab协议和raft协议.
	14. 一个在线文档系统,文档可以被编辑,如何防止多人同时对同一份文档进行编辑更新.
	15. 线上系统突然变得异常缓慢,你如何查找问题.
	16. 说说你平时用到的设计模式.
	17. Dubbo的原理,有看过源码么,数据怎么流转的,怎么实现集群,负载均衡,服务注册和发现,重试转发,快速失败的策略是怎样的 .
	18. 一次RPC请求的流程是什么.
	19. 自己实现过rpc么,原理可以简单讲讲.Rpc要解决什么问题.
	20. 异步模式的用途和意义.
	21. 编程中自己都怎么考虑一些设计原则的,比如开闭原则,以及在工作中的应用.
	22. 设计一个社交网站中的“私信”功能,要求高并发,可扩展等等. 画一下架构图.
	23. MVC模式,即常见的MVC框架.
	24. 聊下曾经参与设计的服务器架构并画图,谈谈遇到的问题,怎么解决的.
	25. 应用服务器怎么监控性能,各种方式的区别.
	26. 如何设计一套高并发支付方案,架构如何设计.
	27. 如何实现负载均衡,有哪些算法可以实现.
	28. Zookeeper的用途,选举的原理是什么.
	29. Zookeeper watch机制原理.
	30. mybatis的底层实现原理.
	31. 请思考一个方案,实现分布式环境下的countDownLatch.
	32. 后台系统怎么防止请求重复提交.
	接口实现幂等
	33. 描述一个服务从发布到被消费的详细过程.
	34. 讲讲你理解的服务治理.
	35. 如何做到接口的幂等性.
	36. 如何做限流策略,令牌桶和漏斗算法的使用场景.
	37. 什么叫数据一致性,你怎么理解数据一致性.
	38. 分布式服务调用方,不依赖服务提供方的话,怎么处理服务方挂掉后,大量无效资源请求的浪费,如果只是服务提供方吞吐不高的时候该怎么做,如果服务挂了,那么一会重启,该怎么做到最小的资源浪费,流量半开的实现机制是什么.
	39. dubbo的泛化调用怎么实现的,如果是你,你会怎么做.
	40. 远程调用会有超时现象,如果做到优雅的控制,JDK自带的超时机制有哪些,怎么实现的.
	
####算法

	1. 10亿个数字里里面找最小的10个.
	2. 有1亿个数字,其中有2个是重复的,快速找到它,时间和空间要最优.
	3. 2亿个随机生成的无序整数,找出中间大小的值.
	4. 给一个不知道长度的（可能很大）输入字符串,设计一种方案,将重复的字符排重.
	基数排序,维护一个256的字符数组
	5. 遍历二叉树.
	前序,中序和后序的非递归以及深度优先和广度优先
	6. 有3n+1个数字,其中3n个中是重复的,只有1个是不重复的,怎么找出来.
	位运算,每一位统计,最后把不能被3整除的位拼起来
	7. 写一个字符串（如：www.javastack.cn）反转函数.
	8. 常用的排序算法,快排,归并,冒泡,快排的最优时间复杂度,最差复杂度,冒泡排序的优化方案.
	9. 二分查找的时间复杂度,优势.
	logN
	10. 一个已经构建好的TreeSet,怎么完成倒排序.
	11. 什么是B+树,B树,列出实际的使用场景.
	12. 一个单向链表,删除倒数第N个数据.
	13. 200个有序的数组,每个数组里面100个元素,找出top20的元素.
	数组多路归并,用个20大小的堆在前面处理,200个数组用个指针处理
	14. 单向链表,查找中间的那个元素.
	快慢指针
	
####数据库知识

	1. 数据库隔离级别有哪些,各自的含义是什么,MYSQL默认的隔离级别是是什么.
	2. 什么是幻读.
	读到不存在的行,mysql的间隙锁不存在这个问题
	3. MYSQL有哪些存储引擎,各自优缺点.
	MyISAM和Innodb
	4. 高并发下,如何做到安全的修改同一行数据.
	加锁或者用乐观锁(简单cas)
	5. 乐观锁和悲观锁是什么,INNODB的标准行级锁有哪2种,解释其含义.
	6. SQL优化的一般步骤是什么,怎么看执行计划,如何理解其中各个字段的含义.
	7. 数据库会死锁吗,举一个死锁的例子,mysql怎么解决死锁.
	8. MYsql的索引原理,索引的类型有哪些,如何创建合理的索引,索引如何优化.
	9. 聚集索引和非聚集索引的区别.
	10. select for update 是什么含义,会锁表还是锁行或是其他.
	11. 为什么要用Btree实现,它是怎么分裂的,什么时候分裂,为什么是平衡的.
	12. 数据库的ACID是什么.
	13. 某个表有近千万数据,CRUD比较慢,如何优化.
	14. Mysql怎么优化table scan的.
	15. 如何写sql能够有效的使用到复合索引.
	注意最左前缀原则
	16. mysql中in和exists区别.
	17. 数据库自增主键可能的问题.
	18. MVCC的含义,如何实现的.
	多版本并发控制
	19. 你做过的项目里遇到分库分表了吗,怎么做的,有用到中间件么,比如sharding jdbc等,他们的原理知道么.
	20. MYSQL的主从延迟怎么解决.
	
	
####消息队列

	1. 消息队列的使用场景.
	2. 消息的重发,补充策略.
	3. 如何保证消息的有序性.
	4. 用过哪些MQ,和其他mq比较有什么优缺点,MQ的连接是线程安全的吗,你们公司的MQ服务架构怎样的.
	5. MQ系统的数据如何保证不丢失.
	6. rabbitmq如何实现集群高可用.
	7. kafka吞吐量高的原因.
	8. kafka和其他消息队列的区别,kafka主从同步怎么实现.
	9. 利用mq怎么实现最终一致性.
	10. 使用kafka有没有遇到什么问题,怎么解决的.
	11. MQ有可能发生重复消费,如何避免,如何做到幂等.
	12. MQ的消息延迟了怎么处理,消息可以设置过期时间么,过期了你们一般怎么处理.
	
####缓存

	1. 常见的缓存策略有哪些,如何做到缓存(比如redis)与DB里的数据一致性,你们项目中用到了什么缓存系统,如何设计的.
	2. 如何防止缓存击穿和雪崩.
	3. 缓存数据过期后的更新如何设计.
	4. redis的list结构相关的操作.
	5. Redis的数据结构都有哪些.
	6. Redis的使用要注意什么,讲讲持久化方式,内存设置,集群的应用和优劣势,淘汰策略等.
	7. redis2和redis3的区别,redis3内部通讯机制.
	8. 当前redis集群有哪些玩法,各自优缺点,场景.
	redis cluster是3.0以后官方提供的集群模式,三主三从
	9. Memcache的原理,哪些数据适合放在缓存中.
	10. redis和memcached 的内存管理的区别.
	11. Redis的并发竞争问题如何解决,了解Redis事务的CAS操作吗.
	12. Redis的选举算法和流程是怎样的.
	13. redis的持久化的机制,aof和rdb的区别.
	14. redis的集群怎么同步的数据的.
	15. 知道哪些redis的优化操作.
	pipeline mget mset 大key和热key单独处理,做好监控
	16. Reids的主从复制机制原理.
	17. Redis的线程模型是什么.
	18. 请思考一个方案,设计一个可以控制缓存总体大小的自动适应的本地缓存.
	19. 如何看待缓存的使用（本地缓存,集中式缓存）,简述本地缓存和集中式缓存和优缺点. 
	20. 本地缓存在并发使用时的注意事项.
	
####搜索

	1. elasticsearch了解多少,说说你们公司es的集群架构,索引数据大小,分片有多少,以及一些调优手段 .elasticsearch的倒排索引是什么.
	2. elasticsearch 索引数据多了怎么办,如何调优,部署.
	3. elasticsearch是如何实现master选举的.
	4. 详细描述一下Elasticsearch索引文档的过程.
	5. 详细描述一下Elasticsearch搜索的过程.
	6. Elasticsearch在部署时,对Linux的设置有哪些优化方法?
	7. lucence内部结构是什么.